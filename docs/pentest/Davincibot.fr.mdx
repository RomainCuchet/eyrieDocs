---
sidebar_position: 1
---

import PdfDownload from '@site/src/components/PdfDownload';

#  Davincibot.fr

Penetration test of [Davincibot.fr](https://davincibot.fr/)

# 1. Supabase Security Analysis

## 1.1 Row Level Security (RLS) Misconfigurations

Supabase leverages PostgreSQL’s Row Level Security (RLS) to enforce access control. Improperly defined policies result in significant unauthorized data access.

### 1.1.1 Information Disclosure via anon Role

```json
{
	"id": "7ee2aa79-2184-464e-87c5-a42dd5521ea4",
	"username":"toto",
	"role":"admin",
	"avatar_url":"https://jumpto.io/scoumg",
	"member_of":["Travelers","CDR"]
}
```

The `anon` (anonymous) role, assigned to unauthenticated requests, is permitted to query sensitive user metadata.

![Formation Users](/img/DVB-2026-001/formation_users.png)

Even though the `/formation` section has its own Supabase instance, it suffers from the same issue. 


**Technical Impact & Risk:**

- Privilege Mapping: Exposing roles (e.g., `admin`) allows attackers to identify high-value targets for social engineering.
- Identity Impersonation Risk: While UUIDs are intended only as identifiers, leaking them enables attackers to target downstream internal services that may incorrectly trust a `user_id` without validating the JWT signature via the `auth.uid()` context.

### 1.1.2 Broken Object Level Authorization (BOLA)

:::danger
The application fails to isolate user records.
Any valid authenticated JWT can be used to exfiltrate the entirety of the `spending` and `order` tables via a broad `SELECT *` query.
:::

#### A. Exfiltration of Financial Records (`spending`)

```json
{
	"id": 1,
	"amount":10.50,
	"date": "2026-01-08T11:06:03.970702+00:00",
	"description": "Avance de Trésorerie de Toto",
	"author_id": "7ee2aa79-2184-464e-87c5-a42dd5521ea4",
	"order_id": null
}
```

I successfully retrieved granular financial data belonging to other users. This exposes the organization's cash flow.

#### B. Exfiltration of Orders & Internal Communications (`order`)

```json
{
	"id":2,
	"creationDate": "2025-01-12T13:51:44.020286+00:00",
	"lastUpdate":  "2025-09-03T13:18:57.791144+00:00",
	"requestedBy": "7ee2aa79-2184-464e-87c5-a42dd5521ea4",
	"comment": "actiators' microcontroller",
	"projectId": 1,
	"status":"completed",
	"tags": ["info"],
	"spending_id": 2,
	"name": "controller" ,
	"price": "19.99",
	"shipping_cost" : 0	
}
```

The `order` table exposure includes a `comment` field used for informal internal dialogue.

**Risk Assessment:**

- Reputational Damage: Leaked private comments can cause internal conflict or public embarrassment.
- Business Intelligence Leak: Full visibility into procurement pricing, project IDs, and internal validation process.

### 1.1.3 Unauthorized Content Modification & Integrity Breach (Blog Management)

:::danger
High Severity: Vertical Access Control Bypass
The application lacks server-side authorization checks for blog management operations. While users are authenticated, the system fails to validate their permissions, allowing any registered user to bypass the UI and manipulate the data layer directly. This results in a persistent breach of content integrity.
:::

#### 1.1.3.1 Technical Exploitation: Stored Content Manipulation

The application’s data persistence layer lacks server-side validation for authorship or administrative roles. I confirmed via intercepted traffic that **Row-Level Security (RLS)** policies on the `blog` table are either misconfigured or non-existent. An attacker can bypass the UI logic to execute `POST`, `PUT`, `PATCH`, and `DELETE` operations directly against the Supabase REST API.

**Key Exploitation Vectors:**

- Silent Defacement: An attacker can alter existing articles. Since the `last_updated` metadata is not enforced by a database trigger, these changes remain invisible to casual inspection.
- Unauthorized Article Submission: By issuing direct `POST` requests to the Supabase REST endpoint, an attacker can create new blog entries without possessing valid author or administrator privileges. This enables the publication of malicious content, phishing links, misinformation, or embedded payloads under the legitimacy of the platform.
- Administrative Blind Spot: The absence of audit logs or real-time webhooks ensures that content deletion or modification occurs without any alerting, granting an attacker indefinite persistence.

##### A. Weaponized Content: High-Trust Phishing Redirection

By modifying high-traffic articles, an attacker can inject malicious redirections or high-trust phishing links.

![Evil Link in Blog](/img/DVB-2026-001/page_blog_evil_link.png)

Impact: This transforms the organization’s official blog into a **malware distribution vector**. Because the domain is trusted, these links will bypass many browser-based security filters and corporate firewalls, leveraging the organization's reputation to victimize its own partners and members.

#### B. Stealth Surveillance: Reader Deanonymization

By injecting controlled image tags or 1-pixel "canary" tokens, an attacker can capture metadata from every reader, including IP addresses (approximate location), User-Agent strings, and engagement timestamps.

![Pixel Attack](/img/DVB-2026-001/pixel_attack.png)

![Click Analytics](/img/DVB-2026-001/click_analytics.png)

As observed, an attacker can use these metrics to refine social engineering campaigns, measuring click-through rates (CTR) on malicious links to optimize their success rate.

#### 1.1.3.2 Vulnerability Analysis: XSS and CSRF

- Cross-Site Scripting (XSS): The website utilizes a standard Markdown sanitization library. While no direct JavaScript execution was achieved during testing, the ability to inject arbitrary Markdown remains a high risk as a vulnerability could be discovered within the parsing library.	
- Cross-Site Request Forgery (CSRF): Testing confirmed that the framework’s built-in security policies (likely SameSite cookie attributes and Origin checks) effectively mitigate standard CSRF attempts.

	![CSRF Blocked](/img/DVB-2026-001/csrf_blocked.png)

## 1.2 Remediation Strategy

To resolve these vulnerabilities, a "Least Privilege" access model must be enforced via PostgreSQL RLS policies.

### 1.2.1 Hardening the anon Role

Restrict the `anon` role from accessing any table containing PII (Personally Identifiable Information) or internal metadata. The `anon` role should only have access to public-facing assets explicitly required for the login/signup flow.

### 1.2.2 Strengthening RLS Policies

The current "Permissive" policies should be replaced with "Restrictive" policies that validate the user's identity.

- For Personal Data: Users should only see their own records.

```SQL
-- Example for the 'spending' table
CREATE POLICY "Users can only view their own spending" 
ON public.spending 
FOR SELECT 
TO authenticated 
USING (auth.uid() = author_id);
```
   
- For Management/Project Leads: Implement Role-Based Access Control (RBAC). Use a join or a metadata check to allow "Project Leads" to see data linked to their specific `projectId`.

### 1.2.3 Restricting Write Access

To mitigate the risks of unauthorized content modification and malicious redirection, the following technical controls must be implemented:

- Access must be restricted based on a verified "Role" attribute. Simple authentication is insufficient.
- To prevent phishing links and tracking pixel attacks described in section 1.3.1, the Markdown rendering engine must be hardened
- Link Sanitization: Implement a strict whitelist for external domains. Any URL not belonging to a pre-approved list (e.g., the association's own domains, trusted partners, or official documentation) should be stripped or rendered as plain text.
- Image Proxying: To prevent IP leakage via 1-pixel trackers use a strict `Content-Security-Policy` (CSP) that restricts `img-src` to trusted origins only.
- Change Notifications: Deploy a Supabase Edge Function triggered by a database webhook. Whenever a `blog` record is created or modified, an automated alert should be sent to a dedicated security channel (e.g., Slack, Discord, or Email).

---
# 2. Website Security Architecture

## 2.1 Insecure Client-Side Authentication & Resource Exposure

The application currently relies on client-side JavaScript logic to protect the `/admin` route. Because the server returns the full page bundle before the browser executes the redirect, all underlying static assets, routing structures, and component logic are exposed to the client by design.

![Admin 200 Response](/img/DVB-2026-001/admin_200.png)

Technical Findings:

- Bypassing the Gatekeeper: By manually manipulating the client-side state (e.g., setting a `role` variable to `admin` in the browser console), I was able to render the full administrative interface populated with data from all misconfigured RLS. 
	![Client-side Admin](/img/DVB-2026-001/client_side_admin.PNG)
	
	![Blog Page](/img/DVB-2026-001/page_blog.png)
- Information Leakage via Status Codes: The server returns `HTTP 200` for existing admin paths and `HTTP 404` for non-existent ones. This discrepancy allows an attacker to "fuzz" and map the administrative attack surface even without a valid account.

	![Directory Search](/img/DVB-2026-001/dirsearch.png)

- Credential Harvesting Risk: With the exfiltrated frontend code, an attacker could host a "mirror" of the admin panel. By populating the UI with exfiltrated user data (from RLS leaks), they could trick legitimate administrators into providing their credentials via a spoofed "Session Expired" prompt.


The "RLS Safety Net" Fallacy: While a perfect RLS configuration would result in an empty UI (as seen below), relying solely on the database for security is a high-risk architecture. If a single RLS policy is misconfigured, the lack of routing protection leads to data leakage.

![Empty Blog Page](/img/DVB-2026-001/page_blog_empty.png)

### 2.1.1 Remediation Strategy: Server-Side Enforcement

To secure the administrative perimeter, the security boundary must shift from the browser to the server (or Edge Network).

- Implement Middleware Guards: Use Server-Side Rendering (SSR) or Middleware (e.g., Next.js Middleware) to intercept requests to `/admin`. The server must validate the JWT **before** serving any HTML or JS.
- Uniform Redirection: For any unauthenticated request to `/admin/*` (regardless of whether the sub-path exists), the server should return a consistent HTTP 303 Redirect to `/auth/login`. This prevents endpoint enumeration via status code analysis.
- HttpOnly Cookie Authentication: Transition from `localStorage` to `HttpOnly` cookies for session management. This allows the server to read the auth token during the initial request and prevents XSS-based token theft.

## 2.3 Exposed Development Artifacts

Several endpoints (e.g., `/formation`) appear to be development or testing artifacts, exposing mock data and incomplete functionalities.

- Risk: Security must not rely on "security by obscurity." Unfinished code often lacks the hardening present in production modules and can provide a "backdoor" or a pivot point into the system.

## 2.4 Risks of Publicly Available Source Code

The availability of the application’s source code in a public GitHub repository represents a significant Information Disclosure vulnerability. This "Open-Source by accident" configuration provides an attacker with a comprehensive blueprint for the system’s architecture, drastically reducing the cost and time required for the Reconnaissance phase of an attack.

### 2.4.1 Leakage of Sensitive Credentials (Exposed Secrets)

![API Key Maps](/img/DVB-2026-001/api_key_maps.png)

:::danger
Hardcoded API Key 
A **Google Maps API Key** was identified in plain text within the project's public repository. Storing secrets in version control (VCS) is a major security anti-pattern that can lead to financial loss or service disruption.
:::

**Risk Analysis:**

- Current Status: The immediate impact is limited as the associated billing account is currently inactive.
- Future Threat: If billing is enabled without rotating this key, an attacker could exfiltrate it to perform unauthorized requests, leading to "Billing Exhaustion" or denial of service for the legitimate application.
- Exploitation: Bots and specialized search engines (like Shodan or GitHub Dorks) constantly crawl public repositories for these specific strings.
### 2.4.2 Technical Impact

- Database Schema Exposure: By inspecting the code, an attacker can map the entire database structure, including table names, relationships, and data types. This enables the crafting of highly precise SQL injection payloads or the exploitation of specific Row-Level Security (RLS) blind spots.
- Endpoint Enumeration: The code explicitly lists all internal and external API endpoints. An attacker does not need to "fuzz" or guess hidden paths; they have a complete list of targets, including administrative and development routes that should remain private.
- Static Analysis & CVE Identification: Public code allows for rapid Static Application Security Testing (SAST). Using automated dependency scanners, I identified critical CVE vulnerabilities within the project's dependencies. In a production environment, this exposure provides a "how-to" guide for executing attacks based on known exploits.

	![CVE Vulnerabilities](/img/DVB-2026-001/cve_vuln.png)
	
- Logic Flaw Discovery: Attackers can analyze the business logic (e.g., how the `/admin` redirection is handled or how blog posts are sanitized) to identify "edge cases" where security checks can be bypassed.

### 2.4.3 Remediation Strategy: Source Code & Secret Recovery

- Immediate Privacy: Transition the GitHub repository to Private mode immediately to prevent further indexing by search engines and automated scrapers.
- Secret Rotation: Assume that any API keys, database strings, or signing secrets present in the Git history are compromised. Rotate them immediately and Implement a secret scanner to prevent this to happen again. 
- Software Composition Analysis (SCA): Integrate tools like Snyk or GitHub Dependency Graph (Dependabot). These tools scan your `package.json` or `requirements.txt` to identify and offer automated patches for known CVEs in your open-source dependencies.
- Static Application Security Testing (SAST): Use SonarQube or CodeQL to analyze your custom code for "Security Hotspots" (e.g., hardcoded secrets, weak cryptographic patterns).
- Secret Scanning: Enable GitHub Secret Scanning and use pre-commit hooks (e.g., `trufflehog` or `gitleaks`) to block any commit containing strings that look like API keys or private certificates.
## 2.5 Infrastructure & Stream Exposure

### 2.5.1 Unauthorized RTSP & FTP Access
:::danger
Publicly accessible RTSP and FTP ports significantly increase the attack surface, potentially allowing unauthorized media interception, data exfiltration, or remote system compromise.
:::

![Ports Scan](/img/DVB-2026-001/ports_scan.png)

As shown in the terminal logs, several high-risk ports are open and externally accessible:

- Port 554 (RTSP): The Real-Time Streaming Protocol is open. The command  
    `nc -v davincibot.fr 554` confirms a successful TCP connection, meaning the service is publicly reachable.
    
    ![Port Scan Connection](/img/DVB-2026-001/port_scan_connect.png)
    
- Port 21 (FTP): The File Transfer Protocol service is active and responding to connections.

**Technical Findings:**

- RTSP Hijacking: RTSP is commonly used for IP cameras or live screen-sharing feeds. Without strict authentication (e.g., Digest Authentication), an attacker could use tools such as `ffplay` or `VLC` to intercept live video streams, enumerate available stream endpoints and potentially inject malicious media streams.
- FTP Filesystem Access: Port 21 enables potential unauthorized interaction with the server’s filesystem. If anonymous login is enabled or weak credentials are in use, an attacker could exfiltrate source code, download configuration files, access sensitive user data and upload malicious files.

:::warning
As soon as I identified the open ports, I noticed that the administrator had shut down the system. As a result, I was unable to further investigate the breach. A forensic analysis should be conducted to determine whether any unauthorized access or compromise occurred.
:::

### 2.5.2 UI Bypass for Screen Sharing

While the `/caroussel` and `/admin/screen-share` routes attempt to hide functionality behind disabled buttons, these are purely cosmetic client-side restrictions.

![SCREEN SHARE](/img/DVB-2026-001/page_screen_share_disabled_button.png)

- Discovery via robots.txt: The path `/caroussel` is indexed, effectively providing attackers with a roadmap of hidden functionality.
- Bypassing `disabled` Attributes:  Removing the `disabled` attribute directly in the browser’s DOM restores full interactivity to the signaling interface.
- WebSocket Hijacking:  
    The service `wss://cast.davincibot.fr` is currently the main bottleneck. However, if brought online without strict **JWT validation during the WebSocket handshake**, any network user could potentially broadcast arbitrary content to site visitors.

### 2.5.3 Remediation: Hardening the Network

- Close Unnecessary Ports:  
    If FTP and RTSP are not required for public operation, they should be firewalled or bound to `localhost`.
- Enforce Strong RTSP Authentication:  
    Require strong credentials and restrict access to trusted IP ranges.
- Secure WebSocket Signaling:  
    Ensure the WebSocket server validates the Supabase `access_token` before permitting any connection to the `cast` subdomain.
    
## 2.6 SVG Profile Picture Uploads

The application allows users to upload SVG (Scalable Vector Graphics) files as profile pictures. While SVGs are popular for their scalability and small file size, they are essentially XML documents, which introduces a unique set of security risks.

### 2.6.1 Stored Cross-Site Scripting (XSS)

Because SVGs can contain embedded `<script>` tags and event handlers (e.g., `onload`), an attacker can craft a malicious image that executes JavaScript when rendered.

The "Direct Access" Trap: While a **Content Security Policy (CSP)** blocks execution when the SVG is rendered inside an `<img>` tag on the main site, the risk changes if a user visits the file URL directly

- Context Shift: When a browser opens an SVG directly, it treats it as an independent XML document. In this context, the SVG becomes the "top-level" window, and embedded scripts can execute.

![SVG ATTACK](/img/DVB-2026-001/svg_attack.png)
	
- Cookie Theft: If the SVG is served from the same domain as your application, the script can access sensitive session cookies or perform actions on behalf of the user within that domain. That isn't the case yet but this issue may arise in future developments.

### 2.6.2 XML External Entity (XXE) Attacks

Since SVGs are XML-based, they are also vulnerable to **XXE injection**. An attacker could upload an SVG that references external entities to:

- Exfiltrate Data: Read local files from the server (if the server parses the SVG during upload).
- Server-Side Request Forgery (SSRF): Force the server to make requests to internal services or external malicious sites.

### 2.6.3 Remediation Strategy

To allow SVGs safely, you must move away from treating them as simple static images.

#### A. Server-Side Sanitization

Never store a raw, user-provided SVG. Use a library like DOMPurify (with an XML parser) or specialized SVG sanitizers to strip out:

- `<script>` tags.
- Event handlers (`onclick`, `onload`).
- External references (`<!ENTITY ...>`).

#### B. Safe Serving Headers

Force the browser to treat the SVG as an image and never as an executable document:

- Content-Disposition: Set this to `attachment` for direct links to force a download instead of in-browser rendering.
- Content-Type: Ensure it is strictly `image/svg+xml`.
- X-Content-Type-Options: Always set to `nosniff`.

#### C. Image Transformation Bypass

Leverage Supabase Image Transformations to serve the SVG as a flattened PNG or WebP.

- Action: When a profile picture is requested, append transformation parameters (e.g., `?width=200&format=webp`).
- Security Benefit: By converting the SVG to a raster format on the fly, any embedded code is physically stripped away, rendering the attack impossible.

#### D. Content Security Policy (CSP)

Ensure your CSP specifically restricts `object-src 'none'` and `script-src` to prevent SVGs from being used as plugins or script carriers.

## 2.7 User Analytics Manipulation

The website utilizes Rybbit for user analytics. While useful for business metrics, analytics must never be used for security monitoring (XDR).

- Data Poisoning: Browser-side telemetry is fully attacker-controlled. An adversary can skew metrics to influence business decisions or, in LLM-integrated workflows, perform Data Poisoning or Prompt Injection if the model relies on this untrusted telemetry for its context.

---

<PdfDownload 
  title="Complete Security Assessment Report"
  description="Download the penetration test report"
  pdfUrl="https://drive.google.com/file/d/1v8n9rfHfNHfDiBj17fq57FNACh7vYTlu/view?usp=sharing"
  fileName="DVB-2026-001.pdf"
/>